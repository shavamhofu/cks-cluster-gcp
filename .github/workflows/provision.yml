
name: ‚öôÔ∏è Provision CKS GCP Cluster

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action (apply/destroy)'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy    

jobs:
  deploy:
    name: üöÄ Provision and Configure Cluster
    runs-on: ubuntu-latest

    env:
    #   TF_ACTION: apply
      TF_ACTION: ${{ github.event.inputs.action || 'apply' }}
      GCP_PROJECT: nice-limiter-460717-s4

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

 
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: '${{ secrets.GCP_CREDENTIALS }}'
          export_default_credentials: true    
      
      - name: üß∞ Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6
# terraform
      - name: üì¶ Terraform Init
        # if: env.TF_ACTION == 'apply'
        run: terraform init
        working-directory: terraform

      - name: üì° Terraform Apply
        if: env.TF_ACTION == 'apply'
        run: terraform apply -auto-approve
        working-directory: terraform

      - name: Terraform Destroy
        if: env.TF_ACTION == 'destroy'
        run: |
            cd terraform
            terraform destroy -auto-approve

 #  ansible
      - name: Install Ansible & Utils
        if: env.TF_ACTION == 'apply'
        run: |
            sudo apt-get update
            sudo apt-get install -y ansible openssh-client inetutils-ping netcat-openbsd jq

     
    #   - name: üîë Extract and Save Terraform SSH Private Key
    #     id: extract_key
    #     if: env.TF_ACTION == 'apply'
    #     run: |
    #         PRIVATE_KEY=$(terraform output -raw private_key_pem)
    #         mkdir -p ~/.ssh
    #         echo "$PRIVATE_KEY" > ~/.ssh/id_rsa
    #         chmod 600 ~/.ssh/id_rsa
    #         echo "private_key_pem<<EOF" >> "$GITHUB_OUTPUT"
    #         echo "$PRIVATE_KEY" >> "$GITHUB_OUTPUT"
    #         echo "EOF" >> "$GITHUB_OUTPUT"
    #     working-directory: terraform
      - name: üîë Extract and Save Terraform SSH Private Key
        id: extract_key
        if: env.TF_ACTION == 'apply'
        run: |
            mkdir -p ~/.ssh
            terraform output -raw private_key_pem > ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa

            echo "private_key_pem<<EOF" >> "$GITHUB_OUTPUT"
            cat ~/.ssh/id_rsa >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
        working-directory: terraform      

      - name: üßæ Generate Ansible Inventory
        if: env.TF_ACTION == 'apply'
        run: |
          chmod +x scripts/generate_inventory_new.sh
          ./scripts/generate_inventory_new.sh

      - name: üîê SSH Keyscan and Add to Known Hosts
        if: env.TF_ACTION == 'apply'
        run: |
          HOSTS=$(grep -v '^#' ansible/inventory.ini | grep 'ansible_host=' | sed -E 's/.*ansible_host=([0-9.]+).*/\1/' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$')
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          
          echo "‚è≥ Waiting 60s for instances to become SSH-ready..."
          sleep 60

          for host in $HOSTS; do
            echo "üîê Scanning SSH key for $host..."
            if ! ssh-keyscan -T 10 -H "$host" >> ~/.ssh/known_hosts; then
                echo "‚ùå Failed to scan SSH key for $host"
                exit 1
            fi
          done

        #   for host in $HOSTS; do
        #     echo "üîê Scanning SSH key for $host..."
        #     ssh-keyscan -H "$host" >> ~/.ssh/known_hosts 2>/dev/null
        #   done
# play books
    #   - name: üõ†Ô∏è Run Ansible Playbooks Master
    #     if: env.TF_ACTION == 'apply'
    #     run: |
    #       PRIVATE_KEY_PEM="${{ steps.extract_key.outputs.private_key_pem }}"
    #       cd ansible 
    #       ansible-playbook -i inventory.ini master.yml --extra-vars "private_key_pem=${PRIVATE_KEY_PEM}" 2>&1 | sed 's/${PRIVATE_KEY_PEM}/[PRIVATE_KEY]/g'
       #   ansible-playbook -i inventory.ini master.yml -vvvv --extra-vars "private_key_pem='${PRIVATE_KEY}'"
          #   ansible-playbook -i inventory.ini master.yml  -vvvv
        #   -e write_join_command=true 
        #   ansible-playbook -i inventory.ini worker.yml -vvvv 

      - name: üõ†Ô∏è Run Ansible Playbooks Master
        if: env.TF_ACTION == 'apply'
        working-directory: ansible
        run: |
            ansible-playbook -i inventory.ini master.yml --extra-vars "private_key_pem=${{ steps.extract_key.outputs.private_key_pem }}"


      - name: üõ†Ô∏è Run Ansible Playbooks Worker
        if: env.TF_ACTION == 'apply'
        run: |
          cd ansible          
          ansible-playbook -i inventory.ini worker.yml -vvvv         
      


